import { Datasource, BBReferenceFieldSubType, FieldType, FormulaType, LegacyFilter, SearchFilters, SearchQueryFields, SortType, FieldConstraints, SortOrder, RowSearchParams, SearchResponse, Table, SearchFilterGroup } from "@budibase/types";
/**
 * Returns the valid operator options for a certain data type
 */
export declare const getValidOperatorsForType: (fieldType: {
    type: FieldType;
    subtype?: BBReferenceFieldSubType;
    formulaType?: FormulaType;
    constraints?: FieldConstraints;
}, field?: string, datasource?: Datasource & {
    tableId: any;
}) => {
    value: string;
    label: string;
}[];
/**
 * Operators which do not support empty strings as values
 */
export declare const NoEmptyFilterStrings: (keyof SearchQueryFields)[];
export declare function recurseLogicalOperators(filters: SearchFilters, fn: (f: SearchFilters) => SearchFilters): SearchFilters;
export declare function recurseSearchFilters(filters: SearchFilters, processFn: (filter: SearchFilters) => SearchFilters): SearchFilters;
/**
 * Removes any fields that contain empty strings that would cause inconsistent
 * behaviour with how backend tables are filtered (no value means no filter).
 *
 * don't do a pure falsy check, as 0 is included
 * https://github.com/Budibase/budibase/issues/10118
 */
export declare const cleanupQuery: (query: SearchFilters) => SearchFilters;
/**
 * Removes a numeric prefix on field names designed to give fields uniqueness
 */
export declare const removeKeyNumbering: (key: string) => string;
/**
 * Gets the part of the keys, returning the numeric prefix and the field name
 */
export declare const getKeyNumbering: (key: string) => {
    prefix?: string;
    key: string;
};
/**
 * Generates a splitter which can be used to split columns from a context into
 * their components (number prefix, relationship column/table, column name)
 */
export declare class ColumnSplitter {
    tableNames: string[];
    tableIds: string[];
    relationshipColumnNames: string[];
    relationships: string[];
    aliases?: Record<string, string>;
    columnPrefix?: string;
    constructor(tables: Table[], opts?: {
        aliases?: Record<string, string>;
        columnPrefix?: string;
    });
    run(key: string): {
        numberPrefix?: string;
        relationshipPrefix?: string;
        tableName?: string;
        column: string;
    };
}
export declare const buildQueryLegacy: (filter?: LegacyFilter[] | SearchFilters) => SearchFilters | undefined;
/**
 * Converts a **SearchFilterGroup** filter definition into a grouped
 * search query of type **SearchFilters**
 *
 * Legacy support remains for the old **SearchFilter[]** format.
 * These will be migrated to an appropriate **SearchFilters** object, if encountered
 *
 * @param filter
 *
 * @returns {SearchFilters}
 */
export declare const buildQuery: (filter?: SearchFilterGroup | LegacyFilter[]) => SearchFilters | undefined;
export declare function fixupFilterArrays(filters: SearchFilters): SearchFilters;
export declare function search<T extends Record<string, any>>(docs: T[], query: Omit<RowSearchParams, "tableId">): SearchResponse<T>;
/**
 * Performs a client-side search on an array of data
 * @param docs the data
 * @param query the JSON query
 */
export declare function runQuery<T extends Record<string, any>>(docs: T[], query: SearchFilters): T[];
/**
 * Performs a client-side sort from the equivalent server-side lucene sort
 * parameters.
 * @param docs the data
 * @param sort the sort column
 * @param sortOrder the sort order ("ascending" or "descending")
 * @param sortType the type of sort ("string" or "number")
 */
export declare function sort<T extends Record<string, any>>(docs: T[], sort: keyof T, sortOrder: SortOrder, sortType?: SortType): T[];
/**
 * Limits the specified docs to the specified number of rows from the equivalent
 * server-side lucene limit parameters.
 * @param docs the data
 * @param limit the number of docs to limit to
 */
export declare function limit<T>(docs: T[], limit: string): T[];
export declare const hasFilters: (query?: SearchFilters) => boolean;
