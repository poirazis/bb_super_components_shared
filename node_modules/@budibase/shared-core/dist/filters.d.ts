import { Datasource, BBReferenceFieldSubType, FieldType, FormulaType, SearchFilter, SearchFilters, SearchQueryFields, SortType, FieldConstraints, SortOrder, RowSearchParams, SearchResponse, Table } from "@budibase/types";
/**
 * Returns the valid operator options for a certain data type
 */
export declare const getValidOperatorsForType: (fieldType: {
    type: FieldType;
    subtype?: BBReferenceFieldSubType;
    formulaType?: FormulaType;
    constraints?: FieldConstraints;
}, field?: string, datasource?: Datasource & {
    tableId: any;
}) => {
    value: string;
    label: string;
}[];
/**
 * Operators which do not support empty strings as values
 */
export declare const NoEmptyFilterStrings: (keyof SearchQueryFields)[];
/**
 * Removes any fields that contain empty strings that would cause inconsistent
 * behaviour with how backend tables are filtered (no value means no filter).
 *
 * don't do a pure falsy check, as 0 is included
 * https://github.com/Budibase/budibase/issues/10118
 */
export declare const cleanupQuery: (query: SearchFilters) => SearchFilters;
/**
 * Removes a numeric prefix on field names designed to give fields uniqueness
 */
export declare const removeKeyNumbering: (key: string) => string;
/**
 * Gets the part of the keys, returning the numeric prefix and the field name
 */
export declare const getKeyNumbering: (key: string) => {
    prefix?: string;
    key: string;
};
/**
 * Generates a splitter which can be used to split columns from a context into
 * their components (number prefix, relationship column/table, column name)
 */
export declare class ColumnSplitter {
    tableNames: string[];
    tableIds: string[];
    relationshipColumnNames: string[];
    relationships: string[];
    constructor(tables: Table[]);
    run(key: string): {
        numberPrefix?: string;
        relationshipPrefix?: string;
        column: string;
    };
}
/**
 * Builds a JSON query from the filter structure generated in the builder
 * @param filter the builder filter structure
 */
export declare const buildQuery: (filter: SearchFilter[]) => SearchFilters;
export declare function fixupFilterArrays(filters: SearchFilters): SearchFilters;
export declare const search: (docs: Record<string, any>[], query: RowSearchParams) => SearchResponse<Record<string, any>>;
/**
 * Performs a client-side search on an array of data
 * @param docs the data
 * @param query the JSON query
 */
export declare const runQuery: (docs: Record<string, any>[], query: SearchFilters) => Record<string, any>[];
/**
 * Performs a client-side sort from the equivalent server-side lucene sort
 * parameters.
 * @param docs the data
 * @param sort the sort column
 * @param sortOrder the sort order ("ascending" or "descending")
 * @param sortType the type of sort ("string" or "number")
 */
export declare const sort: (docs: any[], sort: string, sortOrder: SortOrder, sortType?: SortType) => any[];
/**
 * Limits the specified docs to the specified number of rows from the equivalent
 * server-side lucene limit parameters.
 * @param docs the data
 * @param limit the number of docs to limit to
 */
export declare const limit: (docs: any[], limit: string) => any[];
export declare const hasFilters: (query?: SearchFilters) => boolean;
