import { SvelteComponent, init, safe_not_equal, create_slot, element, set_attributes, insert, get_spread_update, detach, update_slot, transition_in, transition_out, compute_rest_props, assign, exclude_internal_props, binding_callbacks } from 'svelte/internal';
import { onMount, createEventDispatcher } from 'svelte';
import flatpickr from 'flatpickr';

/* src/Flatpickr.svelte generated by Svelte v3.38.2 */

function fallback_block(ctx) {
	let input_1;
	let input_1_levels = [/*$$restProps*/ ctx[1]];
	let input_1_data = {};

	for (let i = 0; i < input_1_levels.length; i += 1) {
		input_1_data = assign(input_1_data, input_1_levels[i]);
	}

	return {
		c() {
			input_1 = element("input");
			set_attributes(input_1, input_1_data);
		},
		m(target, anchor) {
			insert(target, input_1, anchor);
			/*input_1_binding*/ ctx[11](input_1);
		},
		p(ctx, dirty) {
			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]]));
		},
		d(detaching) {
			if (detaching) detach(input_1);
			/*input_1_binding*/ ctx[11](null);
		}
	};
}

function create_fragment(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	return {
		c() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*$$restProps, input*/ 3) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

function stripOn(hook) {
	return hook.charAt(2).toLowerCase() + hook.substring(3);
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["value","formattedValue","element","dateFormat","options","input","flatpickr"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	const hooks = new Set([
			"onChange",
			"onOpen",
			"onClose",
			"onMonthChange",
			"onYearChange",
			"onReady",
			"onValueUpdate",
			"onDayCreate"
		]);

	let { value = "" } = $$props,
		{ formattedValue = "" } = $$props,
		{ element = null } = $$props,
		{ dateFormat = null } = $$props;

	let { options = {} } = $$props;
	let ready = false;
	let { input = undefined } = $$props, { flatpickr: fp = undefined } = $$props;

	onMount(() => {
		const elem = element || input;
		const opts = addHooks(options);

		opts.onReady.push(() => {
			$$invalidate(8, ready = true);
		});

		$$invalidate(3, fp = flatpickr(elem, Object.assign(opts, element ? { wrap: true } : {})));

		return () => {
			fp.destroy();
		};
	});

	const dispatch = createEventDispatcher();

	function addHooks(opts = {}) {
		opts = Object.assign({}, opts);

		for (const hook of hooks) {
			const firer = (selectedDates, dateStr, instance) => {
				dispatch(stripOn(hook), [selectedDates, dateStr, instance]);
			};

			if (hook in opts) {
				// Hooks must be arrays
				if (!Array.isArray(opts[hook])) opts[hook] = [opts[hook]];

				opts[hook].push(firer);
			} else {
				opts[hook] = [firer];
			}
		}

		if (opts.onChange && !opts.onChange.includes(updateValue)) opts.onChange.push(updateValue);
		return opts;
	}

	function updateValue(newValue, dateStr) {
		$$invalidate(2, value = Array.isArray(newValue) && newValue.length === 1
		? newValue[0]
		: newValue);

		$$invalidate(4, formattedValue = dateStr);
	}

	function input_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			input = $$value;
			$$invalidate(0, input);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("value" in $$new_props) $$invalidate(2, value = $$new_props.value);
		if ("formattedValue" in $$new_props) $$invalidate(4, formattedValue = $$new_props.formattedValue);
		if ("element" in $$new_props) $$invalidate(5, element = $$new_props.element);
		if ("dateFormat" in $$new_props) $$invalidate(6, dateFormat = $$new_props.dateFormat);
		if ("options" in $$new_props) $$invalidate(7, options = $$new_props.options);
		if ("input" in $$new_props) $$invalidate(0, input = $$new_props.input);
		if ("flatpickr" in $$new_props) $$invalidate(3, fp = $$new_props.flatpickr);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*fp, ready, value, dateFormat*/ 332) {
			if (fp && ready) {
				fp.setDate(value, false, dateFormat);
			}
		}

		if ($$self.$$.dirty & /*fp, ready, options*/ 392) {
			if (fp && ready) {
				for (const [key, val] of Object.entries(addHooks(options))) {
					fp.set(key, val);
				}
			}
		}
	};

	return [
		input,
		$$restProps,
		value,
		fp,
		formattedValue,
		element,
		dateFormat,
		options,
		ready,
		$$scope,
		slots,
		input_1_binding
	];
}

class Flatpickr extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			value: 2,
			formattedValue: 4,
			element: 5,
			dateFormat: 6,
			options: 7,
			input: 0,
			flatpickr: 3
		});
	}
}

export default Flatpickr;
