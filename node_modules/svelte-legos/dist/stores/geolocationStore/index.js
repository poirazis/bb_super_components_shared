import { readable } from "svelte/store";
async function getPermission() {
    const perm = await navigator.permissions.query({ name: "geolocation" });
    if (perm.state !== "prompt") {
        return perm.state === "granted";
    }
    return true;
}
function getPosition(opts) {
    return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, opts);
    });
}
const initialState = {
    status: "unstarted",
    position: null,
    error: null,
};
export function geolocationStore({ watch, ...options } = { watch: false }) {
    return readable(initialState, (set, update) => {
        const navigator = typeof window !== "undefined" ? window.navigator : null;
        let cancelled = false;
        let watcher;
        if (!(navigator && "geolocation" in navigator)) {
            return update((state) => ({ ...state, status: "unsupported" }));
        }
        const getGeoPosition = async () => {
            if (cancelled)
                return;
            update((state) => ({ ...state, status: "requesting" }));
            const permitted = await getPermission();
            if (!permitted) {
                return update((state) => ({ ...state, status: "unpermitted" }));
            }
            update((state) => ({ ...state, status: "loading" }));
            try {
                const position = await getPosition(options);
                set({ status: "active", position, error: null });
            }
            catch (error) {
                if (error instanceof GeolocationPositionError) {
                    const status = error.code === error.PERMISSION_DENIED ? "unpermitted" : "error";
                    return set({ status, position: null, error });
                }
            }
            if (watch) {
                watcher = navigator.geolocation.watchPosition((position) => set({ status: "active", position, error: null }), (error) => set({ status: "error", position: null, error }), options);
            }
        };
        getGeoPosition();
        return () => {
            cancelled = true;
            if (watcher) {
                navigator.geolocation.clearWatch(watcher);
            }
        };
    });
}
