import { listen } from "svelte/internal";
export const CHECK_INTERVAL = 50;
export const DEFAULT_DELAY = 200;
export const DEFAULT_DISTANCE = 0;
const defaultParams = {
    delay: DEFAULT_DELAY,
    distance: DEFAULT_DISTANCE,
    disabled: false,
    immediate: true,
    cb: () => { },
};
function throttle(fn, delay) {
    let now;
    let lastExec;
    let timer;
    const execute = () => {
        fn();
        lastExec = now;
    };
    return function () {
        now = Date.now();
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
        if (lastExec) {
            const diff = delay - (now - lastExec);
            if (diff < 0) {
                execute();
            }
            else {
                timer = setTimeout(() => {
                    execute();
                }, diff);
            }
        }
        else {
            execute();
        }
    };
}
function getScrollTop(element) {
    if (element === window) {
        return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);
    }
    return element.scrollTop;
}
function getScrollEventTarget(element) {
    let currentNode = element;
    // bugfix, see http://w3help.org/zh-cn/causes/SD9013 and http://stackoverflow.com/questions/17016740/onscroll-function-is-not-working-for-chrome
    while (currentNode &&
        currentNode.tagName !== "HTML" &&
        currentNode.tagName !== "BODY" &&
        currentNode.nodeType === 1) {
        const overflowY = getComputedStyle(currentNode).overflowY;
        if (overflowY === "scroll" || overflowY === "auto") {
            return currentNode;
        }
        currentNode = currentNode.parentElement;
    }
    return window;
}
function getVisibleHeight(element) {
    if (element === window) {
        return document.documentElement.clientHeight;
    }
    return element.clientHeight;
}
function getElementTop(element) {
    if (element === window) {
        return getScrollTop(window);
    }
    return element.getBoundingClientRect().top + getScrollTop(window);
}
function check({ disabled, scrollEventTarget, element, distance, cb, }, force) {
    if (force !== true && disabled)
        return;
    let viewportScrollTop = getScrollTop(scrollEventTarget);
    let viewportBottom = viewportScrollTop + getVisibleHeight(scrollEventTarget);
    let shouldTrigger = false;
    if (scrollEventTarget === element) {
        shouldTrigger = scrollEventTarget.scrollHeight - viewportBottom <= distance;
    }
    else {
        let elementBottom = getElementTop(element) -
            getElementTop(scrollEventTarget) +
            element.offsetHeight +
            viewportScrollTop;
        shouldTrigger = viewportBottom + distance >= elementBottom;
    }
    if (shouldTrigger && cb) {
        cb();
    }
}
export function infiniteScrollAction(node, params = defaultParams) {
    let stop;
    const destroy = () => {
        stop && stop();
    };
    const update = (params) => {
        destroy();
        const scrollEventTarget = getScrollEventTarget(node);
        const scrollEventListener = throttle(check.bind(null, { ...params, scrollEventTarget, element: node }), params.delay);
        const fn = listen(scrollEventTarget, "scroll", scrollEventListener);
        if (params.immediate) {
            check({ ...params, scrollEventTarget, element: node });
        }
        stop = () => {
            fn();
        };
    };
    update({ ...defaultParams, ...params });
    return {
        update,
        destroy,
    };
}
